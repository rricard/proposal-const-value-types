<!DOCTYPE html>
<meta charset="utf8" />
<emu-clause id="sec-ecmascript-data-types-and-values" aoid="Type">
  <h1>ECMAScript Data Types and Values</h1>
  <emu-clause id="sec-ecmascript-language-types">
    <h1>ECMAScript Language Types</h1>

    <emu-clause id="sec-ecmascript-language-types-record-type">
      <h1>The Record Type</h1>
      <p>
        The Record type is the set of all finite mappings from Strings to ECMAScript primitive values including Record and Tuple. Each record value holds an associated [[Fields]] List value which is a list of pairs of the form { [[Key]], [[Value]] } where the [[Key]] is a String and [[Value]] is any primitive value. Entries of [[Fields]] are sorted by [[Key]] in code unit order. The [[Fields]] List and its entries are never modified.
     </p>

      <emu-clause id="sec-makerecordvalue" aoid="MakeRecordValue">
        <h1>MakeRecordValue ( _entries_ )</h1>
        <p>This abstract operation MakeRecordValue takes a _entries_ argument. It is used to specify the creation of new Record value types. It performs the following steps when called:</p>
        <emu-alg>
            1. Assert: _entries_ is a List.
            1. Let _reversedEntries_ be a new List containing the same values as the list _entries_ where the values are ordered as an Array of the same values has been sorted using `Array.prototype.reverse`.
            1. Let _uniqueEntries_ be an empty List.
            1. For each _kv_ in _reversedEntries_:
              1. Assert: Type(_kv_.[[Key]]) is String.
              1. Assert: Type(_kv_.[[Value]]) is not Object.
              1. If there is no entry _existing_ in _uniqueEntries_ such that _existing_.[[Key]] is _kv_.[[Key]], append _kv_ to _uniqueEntries_.
            1. Let _sortedEntries_ be a new List containing the same values as the list _uniqueEntries_ where the values are ordered as if an Array of the same values had been sorted using `Array.prototype.sort` using <emu-xref href="#sec-recordentrycompare">RecordEntryCompare</emu-xref> as _comparefn_.
            1. Let _R_ be a Record value whose [[Fields]] value is _sortedEntries_
            1. Return _R_
        </emu-alg>
      </emu-clause>
    </emu-clause>
    
    <emu-clause id="sec-recordentrycompare" aoid="RecordEntryCompare">
      <h1>RecordEntryCompare ( _kv1_, _kv2_ )</h1>
      <p>This abstract operation RecordEntryCompare takes a _kv1 and _kv2_ argument. It is used to sort record entries when creating a record. It performs the following steps when called:</p>
      <emu-alg>
          1. Assert: _kv1_.[[Key]] is a String.
          1. Assert: _kv2_.[[Key]] is a String.
          1. Return SortCompare(_kv1_.[[Key]], _kv2_.[[Key]])
      </emu-alg>
    </emu-clause>
  </emu-clause>


    <emu-clause id="sec-ecmascript-language-types-tuple-type">
      <h1>The Tuple Type</h1>
      <p>
        The Tuple type is the set of all finite and ordered sequences of ECMAScript primitive values including Record and Tuple. Each tuple value holds an associated [[Sequence]] List which is a list of primitive values. The [[Sequence]] List is integer-indexed. The [[Sequence]] List and its values are never modified.
      </p>
    </emu-clause>

    <emu-clause id="sec-maketuplevalue" aoid="MakeTupleValue">
      <h1>MakeTupleValue ( _values_ )</h1>
      <p>This abstract operation MakeTupleValue takes a _values_ argument. It is used to specify the creation of new Tuple value types. It performs the following steps when called:</p>
      <emu-alg>
          1. Assert: _values_ is a List.
          1. For each _value_ in _values_:
            1. Assert: Type(_value_) is not Object.
          1. Let _T_ be an empty Tuple
          1. Set _T_.[[Sequence]] to _values_
          1. Return _T_
      </emu-alg>
    </emu-clause>
  </emu-clause>
  </emu-clause>
</emu-clause>
